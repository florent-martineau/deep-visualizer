/**
 * Generated by orval v7.13.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface ActivationFunctionResponse {
  activations: ActivationInputOutputPair[];
}

/**
 * Represents the output of an activation function given a particular input.

More details: [here](https://stats.stackexchange.com/a/391685)
 */
export interface ActivationInputOutputPair {
  /** Input to an activation function */
  pre_activation: number;
  /** Output of an activation function */
  activation: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type GetActivationFunctionApiActivationFunctionActivationFunctionNameGetParams = {
/**
 * Minimum value to generate activations from.
 */
min: number;
/**
 * Maximum value to generate activations from.
 */
max: number;
/**
 * Step between each input value. For instance, a step of 0.1 would generate activations for inputs -1.0, -0.9, ...
 */
step: number;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Stores HF Hub User Access Token as an httpOnly secure cookie.
 * @summary Post Access Token
 */
export const postAccessTokenApiAccessTokenPost = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/access-token`,undefined,options
    );
  }



export const getPostAccessTokenApiAccessTokenPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccessTokenApiAccessTokenPost>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAccessTokenApiAccessTokenPost>>, TError,void, TContext> => {

const mutationKey = ['postAccessTokenApiAccessTokenPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAccessTokenApiAccessTokenPost>>, void> = () => {
          

          return  postAccessTokenApiAccessTokenPost(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAccessTokenApiAccessTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof postAccessTokenApiAccessTokenPost>>>
    
    export type PostAccessTokenApiAccessTokenPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Post Access Token
 */
export const usePostAccessTokenApiAccessTokenPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccessTokenApiAccessTokenPost>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAccessTokenApiAccessTokenPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostAccessTokenApiAccessTokenPostMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Deletes the HF Hub User Access Token stored as an httpOnly secure cookie.
 * @summary Delete Access Token
 */
export const deleteAccessTokenApiAccessTokenDelete = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/access-token`,options
    );
  }



export const getDeleteAccessTokenApiAccessTokenDeleteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAccessTokenDelete>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAccessTokenDelete>>, TError,void, TContext> => {

const mutationKey = ['deleteAccessTokenApiAccessTokenDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAccessTokenApiAccessTokenDelete>>, void> = () => {
          

          return  deleteAccessTokenApiAccessTokenDelete(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAccessTokenApiAccessTokenDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAccessTokenApiAccessTokenDelete>>>
    
    export type DeleteAccessTokenApiAccessTokenDeleteMutationError = AxiosError<unknown>

    /**
 * @summary Delete Access Token
 */
export const useDeleteAccessTokenApiAccessTokenDelete = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAccessTokenDelete>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAccessTokenApiAccessTokenDelete>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDeleteAccessTokenApiAccessTokenDeleteMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Checks whether the user has an HF Hub User Access Token stored as an httpOnly cookie, or not. It does **NOT** check the validity of this token. Validity is checked when setting up the cookie, and can be verified when the token is used.
 * @summary Get Access Token
 */
export const getAccessTokenApiAccessTokenGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/access-token`,options
    );
  }


export const getGetAccessTokenApiAccessTokenGetQueryKey = () => {
    return [`http://localhost:8000/api/access-token`] as const;
    }

    
export const getGetAccessTokenApiAccessTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof getAccessTokenApiAccessTokenGet>>, TError = AxiosError<HTTPValidationError>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenApiAccessTokenGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccessTokenApiAccessTokenGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessTokenApiAccessTokenGet>>> = ({ signal }) => getAccessTokenApiAccessTokenGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenApiAccessTokenGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccessTokenApiAccessTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAccessTokenApiAccessTokenGet>>>
export type GetAccessTokenApiAccessTokenGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Access Token
 */

export function useGetAccessTokenApiAccessTokenGet<TData = Awaited<ReturnType<typeof getAccessTokenApiAccessTokenGet>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenApiAccessTokenGet>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccessTokenApiAccessTokenGetQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This function takes as input a range (min, max) and a step. For each value in this interval, it will apply the activation function, and return all the associated activations. This allows you to plot the activation function.
 * @summary Get Activation Function
 */
export const getActivationFunctionApiActivationFunctionActivationFunctionNameGet = (
    activationFunctionName: string,
    params: GetActivationFunctionApiActivationFunctionActivationFunctionNameGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivationFunctionResponse>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/activation-function/${activationFunctionName}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetActivationFunctionApiActivationFunctionActivationFunctionNameGetQueryKey = (activationFunctionName?: string,
    params?: GetActivationFunctionApiActivationFunctionActivationFunctionNameGetParams,) => {
    return [`http://localhost:8000/api/activation-function/${activationFunctionName}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetActivationFunctionApiActivationFunctionActivationFunctionNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getActivationFunctionApiActivationFunctionActivationFunctionNameGet>>, TError = AxiosError<HTTPValidationError>>(activationFunctionName: string,
    params: GetActivationFunctionApiActivationFunctionActivationFunctionNameGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getActivationFunctionApiActivationFunctionActivationFunctionNameGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivationFunctionApiActivationFunctionActivationFunctionNameGetQueryKey(activationFunctionName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivationFunctionApiActivationFunctionActivationFunctionNameGet>>> = ({ signal }) => getActivationFunctionApiActivationFunctionActivationFunctionNameGet(activationFunctionName,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(activationFunctionName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivationFunctionApiActivationFunctionActivationFunctionNameGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActivationFunctionApiActivationFunctionActivationFunctionNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActivationFunctionApiActivationFunctionActivationFunctionNameGet>>>
export type GetActivationFunctionApiActivationFunctionActivationFunctionNameGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Activation Function
 */

export function useGetActivationFunctionApiActivationFunctionActivationFunctionNameGet<TData = Awaited<ReturnType<typeof getActivationFunctionApiActivationFunctionActivationFunctionNameGet>>, TError = AxiosError<HTTPValidationError>>(
 activationFunctionName: string,
    params: GetActivationFunctionApiActivationFunctionActivationFunctionNameGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getActivationFunctionApiActivationFunctionActivationFunctionNameGet>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActivationFunctionApiActivationFunctionActivationFunctionNameGetQueryOptions(activationFunctionName,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
