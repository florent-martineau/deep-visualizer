/**
 * Generated by orval v7.13.1 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface ActivationFunctionResponse {
  activations: ActivationInputOutputPair[];
}

/**
 * Represents the output of an activation function given a particular input.

More details: [here](https://stats.stackexchange.com/a/391685)
 */
export interface ActivationInputOutputPair {
  /** Input to an activation function */
  pre_activation: number;
  /** Output of an activation function */
  activation: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type GetActivationFunctionParams = {
/**
 * Minimum value to generate activations from.
 */
min: number;
/**
 * Maximum value to generate activations from.
 */
max: number;
/**
 * Step between each input value. For instance, a step of 0.1 would generate activations for inputs -1.0, -0.9, ...
 */
step: number;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Stores HF Hub User Access Token as an httpOnly secure cookie.
 * @summary Post Access Token
 */
export const PostAccessToken = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api-proxy/access-token`,undefined,options
    );
  }



export const getPostAccessTokenMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof PostAccessToken>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof PostAccessToken>>, TError,void, TContext> => {

const mutationKey = ['postAccessToken'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof PostAccessToken>>, void> = () => {
          

          return  PostAccessToken(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof PostAccessToken>>>
    
    export type PostAccessTokenMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Post Access Token
 */
export const usePostAccessToken = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof PostAccessToken>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof PostAccessToken>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostAccessTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Deletes the HF Hub User Access Token stored as an httpOnly secure cookie.
 * @summary Delete Access Token
 */
export const DeleteAccessToken = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api-proxy/access-token`,options
    );
  }



export const getDeleteAccessTokenMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof DeleteAccessToken>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof DeleteAccessToken>>, TError,void, TContext> => {

const mutationKey = ['deleteAccessToken'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof DeleteAccessToken>>, void> = () => {
          

          return  DeleteAccessToken(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof DeleteAccessToken>>>
    
    export type DeleteAccessTokenMutationError = AxiosError<unknown>

    /**
 * @summary Delete Access Token
 */
export const useDeleteAccessToken = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof DeleteAccessToken>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof DeleteAccessToken>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDeleteAccessTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Checks whether the user has an HF Hub User Access Token stored as an httpOnly cookie, or not. It does **NOT** check the validity of this token. Validity is checked when setting up the cookie, and can be verified when the token is used.
 * @summary Get Access Token
 */
export const GetAccessToken = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.get(
      `/api-proxy/access-token`,options
    );
  }




export const getGetAccessTokenQueryKey = () => {
    return [
    `/api-proxy/access-token`
    ] as const;
    }

    
export const getGetAccessTokenQueryOptions = <TData = Awaited<ReturnType<typeof GetAccessToken>>, TError = AxiosError<HTTPValidationError>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof GetAccessToken>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccessTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof GetAccessToken>>> = ({ signal }) => GetAccessToken({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof GetAccessToken>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccessTokenQueryResult = NonNullable<Awaited<ReturnType<typeof GetAccessToken>>>
export type GetAccessTokenQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Access Token
 */

export function useGetAccessToken<TData = Awaited<ReturnType<typeof GetAccessToken>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof GetAccessToken>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccessTokenQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This function takes as input a range (min, max) and a step. For each value in this interval, it will apply the activation function, and return all the associated activations. This allows you to plot the activation function.
 * @summary Get Activation Function
 */
export const GetActivationFunction = (
    activationFunctionId: string,
    params: GetActivationFunctionParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivationFunctionResponse>> => {
    
    
    return axios.default.get(
      `/api-proxy/activation-function/${activationFunctionId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetActivationFunctionQueryKey = (activationFunctionId?: string,
    params?: GetActivationFunctionParams,) => {
    return [
    `/api-proxy/activation-function/${activationFunctionId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetActivationFunctionQueryOptions = <TData = Awaited<ReturnType<typeof GetActivationFunction>>, TError = AxiosError<HTTPValidationError>>(activationFunctionId: string,
    params: GetActivationFunctionParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof GetActivationFunction>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivationFunctionQueryKey(activationFunctionId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof GetActivationFunction>>> = ({ signal }) => GetActivationFunction(activationFunctionId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(activationFunctionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof GetActivationFunction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActivationFunctionQueryResult = NonNullable<Awaited<ReturnType<typeof GetActivationFunction>>>
export type GetActivationFunctionQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Activation Function
 */

export function useGetActivationFunction<TData = Awaited<ReturnType<typeof GetActivationFunction>>, TError = AxiosError<HTTPValidationError>>(
 activationFunctionId: string,
    params: GetActivationFunctionParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof GetActivationFunction>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActivationFunctionQueryOptions(activationFunctionId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
